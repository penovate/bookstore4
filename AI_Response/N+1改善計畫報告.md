# N+1 改善計畫報告

本報告針對商品模組、進退貨模組及讀書會模組的 N+1 效能問題提供完整的分析與改善建議。

---

## 1. 商品模組 (Product Module)

### 問題核心

[BooksBean](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/bean/BooksBean.java#33-231) 與 [BookImageBean](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/bean/BookImageBean.java#15-75) 之間的一對一關聯 (`@OneToOne`) 預設為 `EAGER` (立即載入)。當查詢 N 本書籍時，Hibernate 會執行 1 次查詢取得書籍列表，接著執行 N 次查詢取得每一本書的圖片資訊。即使是 Lazy Loading，若在序列化 (JSON) 時讀取了該欄位，同樣會觸發 N+1。

### 建議方案：使用 `@EntityGraph` 優化查詢

#### 程式碼前後對比

**Entity 層 ([BooksBean.java](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/bean/BooksBean.java))**

- **Before (存在隱患)**

  ```java
  @OneToOne(mappedBy = "book", cascade = CascadeType.ALL, orphanRemoval = true)
  // 預設 FetchType.EAGER，查詢 Master 時會立即查詢 Detail
  private BookImageBean bookImageBean;
  ```

- **After (改善設定)**
  ```java
  @OneToOne(mappedBy = "book", fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval = true)
  // 明確指定 LAZY，只有被呼叫或在 EntityGraph 中指定時才載入
  private BookImageBean bookImageBean;
  ```

**Repository 層 ([BookRepository.java](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/repository/BookRepository.java))**

- **Before (N+1)**

  ```java
  List<BooksBean> findAll();
  // 執行 1 次 SELECT books，然後對每本書執行 SELECT book_images
  ```

- **After (一次性載入)**
  ```java
  @EntityGraph(attributePaths = {"bookImageBean", "genres"})
  List<BooksBean> findAll();
  // 執行 1 次 SELECT books LEFT JOIN book_images LEFT JOIN genres
  ```

#### 效能差異

- **Before**: 若有 50 本書，需執行 **51 次 SQL 查詢** (1 + 50)。
- **After**: 僅需執行 **1 次 SQL 查詢**。資料庫負擔大幅降低，網路傳輸次數減少。

#### 底層邏輯差異

- **EAGER / Lazy (N+1)**: 依賴 Hibernate 的 Proxy 機制，當存取未載入的屬性時，觸發額外的 JDBC 請求。
- **EntityGraph**: 在產生 SQL 階段就將關聯表加入 `JOIN` 子句，直接映射回完整的 Entity Graph，避免二次查詢。

#### 替代方案比較

| 方案              | 實作方式                 | 優點                                                             | 缺點                                  |
| :---------------- | :----------------------- | :--------------------------------------------------------------- | :------------------------------------ | -------------------------------------------------------------------- |
| **方法 A (推薦)** | **EntityGraph**          | 宣告式註解，保持 Interface 簡潔，不需寫 JPQL。                   | 無法精細控制 SQL (如複雜的過濾條件)。 |
| **方法 B**        | **JPQL JOIN FETCH**      | `@Query("SELECT b FROM BooksBean b JOIN FETCH b.bookImageBean")` | 完全控制 SQL 語法。                   | 程式碼較冗長，若有多個關聯需小心 Cartesian Product (笛卡兒積) 問題。 |
| **方法 C**        | **Hibernate @BatchSize** | 在 Entity 類別上加 `@BatchSize(size=20)`                         | 設定簡單，對所有查詢生效。            | 只是將 N+1 變成 (N/BatchSize)+1，並非完全解決。                      |

---

## 2. 進退貨模組 (Stock/Return Module)

### 問題核心

Service 層的 [insertStockLog](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/service/StockLogService.java#78-135) 方法在迴圈中逐筆呼叫 [findById](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/service/UsersService.java#40-43) 來查詢書籍庫存，這是典型的「迴圈查詢 (Loop Query)」問題，屬於應用層的 N+1。

### 建議方案：批次查詢 (Batch Fetching)

#### 程式碼前後對比

**Service 層 ([StockLogService.java](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/service/StockLogService.java))**

- **Before (迴圈 N+1)**

  ```java
  for (LogItemBean item : items) {
      // 在迴圈內執行 SQL 查詢
      Optional<BooksBean> bookOpt = bookRepository.findById(item.getBooksBean().getBookId());
      // ... 處理邏輯
  }
  ```

- **After (批次處理)**

  ```java
  // 1. 收集所有 Book ID
  List<Integer> bookIds = items.stream()
      .map(item -> item.getBooksBean().getBookId())
      .collect(Collectors.toList());

  // 2. 執行 1 次資料庫查詢
  List<BooksBean> books = bookRepository.findAllById(bookIds);

  // 3. 轉換為 Map 加速查找
  Map<Integer, BooksBean> bookMap = books.stream()
      .collect(Collectors.toMap(BooksBean::getBookId, b -> b));

  // 4. 記憶體內處理邏輯
  for (LogItemBean item : items) {
      BooksBean book = bookMap.get(item.getBooksBean().getBookId());
      // ...
  }
  ```

#### 效能差異

- **Before**: 若進貨單有 100 個品項，需執行 **100 次 SQL 查詢**。
- **After**: 無論品項多少，僅執行 **1 次 SQL 查詢** (`SELECT ... WHERE id IN (...)`)。

#### 底層邏輯差異

- **Loop Query**: 每次 [findById](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/service/UsersService.java#40-43) 都會開啟一個直到資料庫的 Round-trip，資料庫需解析 SQL 100 次。
- **Batch Query**: 利用 SQL 的 `IN` 子句，一次傳輸所有 ID，資料庫只需解析並執行一次優化計畫。

#### 替代方案比較

| 方案              | 實作方式                         | 優點                         | 缺點                                 |
| :---------------- | :------------------------------- | :--------------------------- | :----------------------------------- | ------------------------------------------------------------- |
| **方法 A (推薦)** | **Service 層重構 (findAllById)** | 效能最好，明確控制查詢次數。 | 需重構 Java 邏輯，程式碼更動量稍大。 |
| **方法 B**        | **JPA 2nd Level Cache**          | 開啟 Hibernate 二級快取。    | 若資料命中快取可避免 SQL。           | 快取設定複雜，且對於庫存這種頻繁變動資料不適合 (容易 Stale)。 |

---

## 3. 讀書會模組 (Book Club Module)

### 問題核心

[BookClubsBean](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/bean/BookClubsBean.java#15-88) 中與 [ClubDetail](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/bean/ClubDetail.java#13-47) 的關聯預設為 `EAGER`，且在列表顯示時，需顯示主辦人 (`host`) 與書籍 ([book](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/service/bookService.java#27-410)) 名稱。這導致查詢列表時，不僅會 `JOIN` Detail 表，若未處理 Lazy 載入，序列化時還會對 Host 和 Book 發出查詢。

### 建議方案：DTO 投影 (DTO Projection)

#### 程式碼前後對比

**Repository 層 ([BookClubsRepository.java](file:///c:/Users/User/Desktop/Project/bookstore4/src/main/java/bookstore/repository/BookClubsRepository.java))**

- **Before (Entity 查詢)**

  ```java
  List<BookClubsBean> findAll();
  // 查回整個 Entity，包含不需要的大欄位 (如 description, big text)
  // 觸發關聯查詢
  ```

- **After (DTO 投影)**
  ```java
  // 定義一個包含列表所需欄位的 Record 或 Class
  // 寫 JPQL 直接選取需要的欄位
  @Query("SELECT new bookstore.dto.BookClubListDTO(c.clubId, c.clubName, h.userName, b.bookName, c.eventDate, c.status) " +
         "FROM BookClubsBean c " +
         "JOIN c.host h " +
         "JOIN c.book b")
  List<BookClubListDTO> findAllForList();
  ```

#### 效能差異

- **Before**: 查詢全部欄位 + N 次關聯查詢 (Host/Book) + 1 次 Detail 查詢 (若 Eager)。
- **After**: **1 次 SQL 查詢**，且只撈取需要的 5-6 個欄位，不撈取大欄位 (CLOB/Text)，資料量最小。

#### 底層邏輯差異

- **Entity loading**: 這是「物件導向」的思維，取出完整物件狀態，由 Persistence Context 管理。適合用於「修改」場景。
- **DTO Projection**: 這是「資料導向」的思維，直接將 SQL 結果映射為 POJO，繞過 Entity 生命週期管理。適合用於「唯讀列表」場景。

#### 替代方案比較

| 方案              | 實作方式           | 優點                                    | 缺點                                                              |
| :---------------- | :----------------- | :-------------------------------------- | :---------------------------------------------------------------- |
| **方法 A (推薦)** | **DTO Projection** | 效能最佳 (只查必要欄位)，完全避免 N+1。 | 需額外定義 DTO 類別，寫 JPQL。                                    |
| **方法 B**        | **EntityGraph**    | 保留 Entity 結構，設定簡單。            | 仍會查出 Entity 所有欄位 (雖然解決了 N+1 關聯，但 Payload 較大)。 |

---

## 綜合總結

| 模組       | 主要瓶頸             | 推薦解法                   | 效益                                            |
| :--------- | :------------------- | :------------------------- | :---------------------------------------------- |
| **商品**   | 圖片/類型關聯載入    | **EntityGraph**            | 51 Query -> 1 Query (查詢列表時)                |
| **進退貨** | 迴圈資料庫查詢       | **Service 層 Batch Query** | 100+ Query -> 1 Query (新增單據時)              |
| **讀書會** | 大量關聯與不必要欄位 | **DTO Projection**         | 減少 N+1 且減少 50% 以上資料傳輸量 (列表顯示時) |
